#include <Arduino.h>
#include <BLEDevice.h>
#include <BLEScan.h>
#include <WiFi.h>
#include <WebServer.h>
#include <FS.h>
#include <SD.h>
#include <SPI.h>
#include <Preferences.h>
#include "RTClib.h"
#include <math.h>
#include <time.h>
#include "esp_bt.h"

/* ================== PINS ================== */
#define LED_PIN 2
#define LED_R   2
#define LED_G   25
#define LED_B   26
#define SD_CS_PIN 5
#define BOOT_BTN 0

#define WEB_SESSION_MS (3 * 60 * 1000UL)
#define BLE_CHECK_INTERVAL 5000UL   // 5 sec watchdog

/* ================== WIFI ================== */
const char* WIFI_SSID = "VANTARA";
const char* WIFI_PASS = "VANTARA@123";
const char* AP_SSID   = "EGG-ROTATION-TRACKER";
const char* AP_PASS   = "12345678";

/* ================== BLE ================== */
static BLEUUID serviceUUID("6E400001-B5A3-F393-E0A9-E50E24DCCA9E");
static BLEUUID charUUID   ("6E400003-B5A3-F393-E0A9-E50E24DCCA9E");

/* ================== PACKET ================== */
#define PACKET_LEN 17
#define HDR1 0xAA
#define HDR2 0x55

uint8_t pkt[PACKET_LEN];
uint8_t idx = 0;

enum RX_STATE { WAIT_H1, WAIT_H2, READ_BODY };
RX_STATE rxState = WAIT_H1;

/* ================== STATE ================== */
enum RUN_MODE { MODE_BLE, MODE_WEB };
RUN_MODE currentMode = MODE_BLE;

bool doConnect = false;
bool bleConnected = false;

unsigned long lastBleCheck = 0;

/* ================== OBJECTS ================== */
BLEAdvertisedDevice* myDevice = nullptr;
BLEClient* bleClient = nullptr;

RTC_DS3231 rtc;
Preferences prefs;
WebServer server(80);

uint32_t packetCounter = 0;
unsigned long webStartTime = 0;

/* ================== LED ================== */
void rgbOff() {
  digitalWrite(LED_R, LOW);
  digitalWrite(LED_G, LOW);
  digitalWrite(LED_B, LOW);
}

void rgbRed() {
  rgbOff();
  digitalWrite(LED_R, HIGH);
}

void rgbGreen() {
  rgbOff();
  digitalWrite(LED_G, HIGH);
}

void rgbBlue() {
  rgbOff();
  digitalWrite(LED_B, HIGH);
}

void blinkLED(uint8_t n = 1) {
  while (n--) {
    digitalWrite(LED_G, HIGH);
    delay(40);
    digitalWrite(LED_G, LOW);
    delay(40);
  }
}

/* ================== RTC ================== */
String rtcDate() {
  DateTime n = rtc.now();
  char b[16];
  sprintf(b, "%04d-%02d-%02d", n.year(), n.month(), n.day());
  return String(b);
}

String rtcTime() {
  DateTime n = rtc.now();
  char b[16];
  sprintf(b, "%02d:%02d:%02d", n.hour(), n.minute(), n.second());
  return String(b);
}

/* ================== BLE NOTIFY ================== */
static void notifyCallback(
  BLERemoteCharacteristic*,
  uint8_t* data,
  size_t len,
  bool
) {
  for (size_t i = 0; i < len; i++) {
    uint8_t b = data[i];

    switch (rxState) {
      case WAIT_H1:
        if (b == HDR1) rxState = WAIT_H2;
        break;

      case WAIT_H2:
        if (b == HDR2) {
          pkt[0] = HDR1;
          pkt[1] = HDR2;
          idx = 2;
          rxState = READ_BODY;
        } else rxState = WAIT_H1;
        break;

      case READ_BODY:
        pkt[idx++] = b;
        if (idx == PACKET_LEN) {
          rxState = WAIT_H1;
          idx = 0;
          goto PARSE;
        }
        break;
    }
  }
  return;

PARSE:
  uint8_t cs = 0;
  for (int i = 2; i <= 15; i++) cs ^= pkt[i];
  if (cs != pkt[16]) return;

  int16_t ax = pkt[2] | (pkt[3] << 8);
  int16_t ay = pkt[4] | (pkt[5] << 8);
  int16_t az = pkt[6] | (pkt[7] << 8);
  int16_t gx = pkt[8] | (pkt[9] << 8);
  int16_t gy = pkt[10] | (pkt[11] << 8);
  int16_t gz = pkt[12] | (pkt[13] << 8);
  int8_t temp = pkt[14];
  uint8_t batt = pkt[15];

  packetCounter++;
  prefs.putUInt("cnt", packetCounter);

  float pitch = atan2(ay, az) * 57.2958;
  float roll  = atan2(-ax, sqrt(ay * ay + az * az)) * 57.2958;

  String file = "/log_" + rtcDate() + ".csv";

  if (!SD.exists(file)) {
    File f = SD.open(file, FILE_WRITE);
    f.println("Date,Time,Count,AX,AY,AZ,GX,GY,GZ,Pitch,Roll,Temp,Battery");
    f.close();
  }

  File f = SD.open(file, FILE_APPEND);
  if (!f) return;

  f.printf(
    "%s,%s,%lu,%d,%d,%d,%d,%d,%d,%.2f,%.2f,%d,%d\n",
    rtcDate().c_str(), rtcTime().c_str(), packetCounter,
    ax, ay, az, gx, gy, gz, pitch, roll, temp, batt
  );
  f.close();

  blinkLED(1);   // data blink
}

/* ================== BLE SCAN ================== */
class MyAdvertisedDeviceCallbacks : public BLEAdvertisedDeviceCallbacks {
  void onResult(BLEAdvertisedDevice dev) {
    if (dev.haveServiceUUID() && dev.isAdvertisingService(serviceUUID)) {
      BLEDevice::getScan()->stop();
      myDevice = new BLEAdvertisedDevice(dev);
      doConnect = true;
    }
  }
};

bool connectToServer() {
  bleClient = BLEDevice::createClient();

  if (!bleClient->connect(myDevice)) {
    bleConnected = false;
    return false;
  }

  BLERemoteService* svc = bleClient->getService(serviceUUID);
  if (!svc) return false;

  BLERemoteCharacteristic* ch = svc->getCharacteristic(charUUID);
  if (!ch) return false;

  ch->registerForNotify(notifyCallback);

  bleConnected = true;
  rgbGreen();
  blinkLED(2);
  Serial.println("BLE connected");

  return true;
}

void startBLE() {
  BLEDevice::init("");
  BLEScan* scan = BLEDevice::getScan();
  scan->setAdvertisedDeviceCallbacks(new MyAdvertisedDeviceCallbacks());
  scan->setActiveScan(true);
  scan->start(0);
  rgbRed();   // initially not connected
}

void stopBLE() {
  BLEDevice::deinit(true);
  btStop();
  delay(200);
}

/* ================== WEB UI ================== */
void handleRoot() {
  server.send(200, "text/html", R"rawliteral(
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>ESP32 SD Log Viewer</title>
<style>
body {
  font-family: Arial, sans-serif;
  background:#f5f6fa;
  margin:0;
  padding:20px;
}
h2 {
  color:#2c3e50;
}
.container {
  display:flex;
  gap:20px;
}
.file-list {
  width:30%;
  background:#fff;
  border:1px solid #ccc;
  height:80vh;
  overflow:auto;
}
.file {
  padding:10px;
  border-bottom:1px solid #eee;
  cursor:pointer;
}
.file:hover {
  background:#ecf0f1;
}
.viewer {
  width:70%;
  background:#fff;
  border:1px solid #ccc;
  padding:10px;
  overflow:auto;
}
button {
  padding:8px 12px;
  margin-top:10px;
  background:#3498db;
  color:white;
  border:none;
  cursor:pointer;
  border-radius:4px;
}
button:hover {
  background:#2980b9;
}
table {
  border-collapse:collapse;
  width:100%;
}
th, td {
  border:1px solid #ccc;
  padding:6px;
  text-align:center;
}
th {
  background:#006e5f;
  color:white;
}
pre {
  white-space:pre-wrap;
}
@media print {
  button { display:none; }
}
</style>
</head>

<body>
<h2>ESP32 SD Card Log Viewer</h2>

<div class="container">
  <div class="file-list" id="files"></div>
  <div class="viewer" id="viewer">Select a file</div>
</div>

<script>
let currentFile = "";

function loadFiles() {
  fetch('/api/list')
    .then(r => r.json())
    .then(files => {
      const list = document.getElementById('files');
      list.innerHTML = '';
      files.forEach(f => {
        const div = document.createElement('div');
        div.className = 'file';
        div.textContent = f.name + ' (' + f.size + ' bytes)';
        div.onclick = () => openFile(f.name);
        list.appendChild(div);
      });
    });
}

function openFile(name) {
  currentFile = name;
  fetch('/api/file?name=' + name)
    .then(r => r.text())
    .then(text => {
      const viewer = document.getElementById('viewer');
      let content = '';

      if (name.endsWith('.csv')) {
        content = csvToTable(text);
      } else {
        content = '<pre>' + text + '</pre>';
      }

      content += `
        <br>
        <button onclick="printLog()">Print</button>
        <button onclick="downloadFile()">Download</button>
      `;
      viewer.innerHTML = content;
    });
}

function downloadFile() {
  window.location.href = '/api/download?name=' + currentFile;
}

function printLog() {
  window.print();
}

function csvToTable(text) {
  let html = '<table>';
 const rows = text.trim().split(/\r?\n/);
 rows.forEach((row, i) => {
    html += '<tr>';
    row.split(',').forEach(col => {
      html += i === 0 ? '<th>' + col + '</th>' : '<td>' + col + '</td>';
    });
    html += '</tr>';
  });
  html += '</table>';
  return html;
}

loadFiles();
</script>
</body>
</html>
)rawliteral");
}



void handleList() {
  File root = SD.open("/");
  String json = "[";
  while (true) {
    File f = root.openNextFile();
    if (!f) break;
    if (json.length() > 1) json += ",";
    json += "{\"name\":\"" + String(f.name()) + "\",\"size\":" + String(f.size()) + "}";
    f.close();
  }
  json += "]";
  server.send(200, "application/json", json);
}

void handleFile() {
  if (!server.hasArg("name")) return;
  File f = SD.open("/" + server.arg("name"));
  if (!f) return;
  server.streamFile(f, "text/plain");
  f.close();
}

void handleDownload() {
  if (!server.hasArg("name")) return;
  File f = SD.open("/" + server.arg("name"));
  if (!f) return;
  server.sendHeader("Content-Disposition", "attachment");
  server.streamFile(f, "application/octet-stream");
  f.close();
}

void startWebServer() {
  rgbBlue();
  WiFi.mode(WIFI_AP);
  WiFi.softAP(AP_SSID, AP_PASS);

  server.on("/", handleRoot);
  server.on("/api/list", handleList);
  server.on("/api/file", handleFile);
  server.on("/api/download", handleDownload);

  server.begin();
  webStartTime = millis();
}

/* ================== SETUP ================== */
void setup() {
  Serial.begin(115200);

  pinMode(LED_R, OUTPUT);
  pinMode(LED_G, OUTPUT);
  pinMode(LED_B, OUTPUT);
  pinMode(BOOT_BTN, INPUT_PULLUP);

  rtc.begin();

  if (!SD.begin(SD_CS_PIN)) {
    Serial.println("SD FAIL");
    while (1);
  }

  prefs.begin("ble-log", false);
  packetCounter = prefs.getUInt("cnt", 0);

  startBLE();
}

/* ================== LOOP ================== */
void loop() {

  if (currentMode == MODE_BLE) {

    if (doConnect) {
      connectToServer();
      doConnect = false;
    }

    /* -------- BLE watchdog -------- */
    if (millis() - lastBleCheck > BLE_CHECK_INTERVAL) {
      lastBleCheck = millis();

      if (bleClient && !bleClient->isConnected()) {
        bleConnected = false;
        rgbRed();
        BLEDevice::getScan()->start(0);
      }

      if (bleClient && bleClient->isConnected()) {
        bleConnected = true;
        rgbGreen();
      }
    }

    if (digitalRead(BOOT_BTN) == LOW) {
      delay(50);
      rgbOff();
      if (digitalRead(BOOT_BTN) == LOW) {
        blinkLED(3);
        stopBLE();
        startWebServer();
        currentMode = MODE_WEB;
      }
    }
  }

  else if (currentMode == MODE_WEB) {
    server.handleClient();
    if (millis() - webStartTime > WEB_SESSION_MS) ESP.restart();
  }
}
